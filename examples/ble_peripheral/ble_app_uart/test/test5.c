#include "nrf_drv_spi.h"
#include "nrf_drv_timer.h"
#include "nrfx_gpiote.h"
#include "nrf_drv_ppi.h"

#include "nrf_log.h"

#include "FreeRTOS.h"
#include "task.h"

#include "../howland.h"
#include "../timing.h"
#include "test.h"

static void test5_spi_timer_callback(nrf_timer_event_t event_type, void * p_context)
{
    NRF_LOG_INFO("test5 spi timer cb");
}

static void test5_spi_event_handler(nrf_drv_spi_evt_t const *p_event, void *p_context)
{
    NRF_LOG_INFO("test5 spi evt handler");
}

/**
 * on osilloscope, hook ch1 to ss pin and ch2 to clk pin, we are going to see
 * a ss pin pull down and then pull up with a width of slightly greater than 3uS.
 * and inside the negative pulse, there are 16 clocks, which are spi clocks for writing a command.
 * the delay between ss pin pull-down and first rising edge of spi clock is greater than 500ns and less than
 * 1us (around 600-700ns); and the delay between the last falling edge of spi clock and the final pull-up
 * of ss pin is around 500ns.
 *
 * in this test, spi timer channel 0 generate a compare event at 1 sec.
 * this event fork triggers both ss pin pull down and spi write. the delay mentioned above is 
 * intrinsically generated by hardware ip.
 * 
 * spi end event triggers ss pin pull-up. Also, the after-delay is intrinsically generated by hardware.
 * 
 * spi xfer is started asynchronously with HOLD and REPEATED flags.
 * it is verified that with or without NO_XFER_EVT_HANDLER has no impact on timing. Both works.
 *
 * The following are original comment, just leave it here, could be removed.
 * test5 tries to repeatedly start spi (hold) xfer by ppi. Also, ss signal triggered by the SAME event source.
 *
 * spi timer compare0 is used as event source, triggering ss toggle (cs low), as well as spi task using fork.
 * spi end triggers the other ss toggle (cs high) in the same cycle.
 * spi timer also has a rewind (compare1) for repetition.
 *
 * a dummy write (wtm) used as spi xfer data. ss signal and spi clock are verified as expected on
 * oscilloscope.
 */
void test5(void)
{
    uint32_t err, event_addr, task_addr;

    // gpio init ss pin
    err = nrfx_gpiote_init();
    APP_ERROR_CHECK(err);

    nrfx_gpiote_out_config_t ss_pin_config = NRFX_GPIOTE_CONFIG_OUT_TASK_TOGGLE(true); // task pin, initial high
    err = nrfx_gpiote_out_init(DAC_SPI_SS_PIN, &ss_pin_config);
    APP_ERROR_CHECK(err);

    nrfx_gpiote_out_task_enable(DAC_SPI_SS_PIN);

    // spi init
    static dac_spi_ctx_t ctx = { 0 };
    err = nrf_drv_spi_init(&m_dac_spi, &m_dac_spi_config, test5_spi_event_handler, &ctx);
    APP_ERROR_CHECK(err);

    // spi timer init
    nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG;
    timer_cfg.frequency = NRF_TIMER_FREQ_16MHz;
    err = nrf_drv_timer_init(&m_spi_timer, &timer_cfg, test5_spi_timer_callback);
    APP_ERROR_CHECK(err);

    // spi timer channel 0 compare 1 second to generate interrupt
    nrf_drv_timer_compare(&m_spi_timer,
                          NRF_TIMER_CC_CHANNEL0,
                          1000 * 1000, // 100,
                          true);
    
    // spi timer channel 1 compare 3 seconds and rewind (no interrupt)
    nrf_drv_timer_extended_compare(&m_spi_timer,
                                   NRF_TIMER_CC_CHANNEL1,
                                   3000 * 1000, // 10 * 1000,
                                   NRF_TIMER_SHORT_COMPARE1_CLEAR_MASK,
                                   false);

    nrf_ppi_channel_t ppic_timc0;
    nrf_ppi_channel_t ppic_spi_end;

    // spi timer channel 0 triggers ss pin toggle (pull down supposedly)
    err = nrfx_ppi_channel_alloc(&ppic_timc0);
    APP_ERROR_CHECK(err);
    
    event_addr = nrfx_timer_compare_event_address_get(&m_spi_timer, NRF_TIMER_CC_CHANNEL0);
    task_addr = nrfx_gpiote_out_task_addr_get(DAC_SPI_SS_PIN);
    
    err = nrfx_ppi_channel_assign(ppic_timc0, event_addr, task_addr);
    APP_ERROR_CHECK(err);

    // spi timer channel 0 fork-triggers spi task (on hold) 
    task_addr = nrf_drv_spi_start_task_get(&m_dac_spi);
    err = nrfx_ppi_channel_fork_assign(ppic_timc0, task_addr);

    err = nrfx_ppi_channel_enable(ppic_timc0);
    APP_ERROR_CHECK(err);

    // spi end event triggers ss pin toggle (pull up supposedly)
    err = nrfx_ppi_channel_alloc(&ppic_spi_end);
    APP_ERROR_CHECK(err);

    event_addr = nrf_drv_spi_end_event_get(&m_dac_spi);
    task_addr = nrfx_gpiote_out_task_addr_get(DAC_SPI_SS_PIN);

    err = nrfx_ppi_channel_assign(ppic_spi_end, event_addr, task_addr);
    APP_ERROR_CHECK(err);

    err = nrfx_ppi_channel_enable(ppic_spi_end);
    APP_ERROR_CHECK(err);

    // spi start
    static uint8_t wt[2] = { 0x90, 0x00 }; // set wtm mode
    static nrf_drv_spi_xfer_desc_t xfer = {
        .p_tx_buffer = wt,
        .tx_length = 2
    };

    uint32_t flags =
        NRF_DRV_SPI_FLAG_HOLD_XFER |
        // NRF_DRV_SPI_FLAG_RX_POSTINC |
        NRF_DRV_SPI_FLAG_NO_XFER_EVT_HANDLER | // <- is this necessary? print only? try it!
        NRF_DRV_SPI_FLAG_REPEATED_XFER;
    err = nrf_drv_spi_xfer(&m_dac_spi, &xfer, flags);
    APP_ERROR_CHECK(err);

    nrf_drv_timer_enable(&m_spi_timer);
}
